.//=====================================================================
.//
.// File:      $RCSfile$
.// Version:   $Revision$
.// Modified:  $Date$
.//
.// (c) Copyright 2006-2014 by Mentor Graphics Corp.  All rights reserved.
.//
.//=======================================================================
.// Licensed under the Apache License, Version 2.0 (the "License"); you may not
.// use this file except in compliance with the License.  You may obtain a copy
.// of the License at
.//
.//      http://www.apache.org/licenses/LICENSE-2.0
.//
.// Unless required by applicable law or agreed to in writing, software
.// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
.// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
.// License for the specific language governing permissions and limitations under
.// the License.
.//=======================================================================
.//
.// This file is responsible for creating the adapters that decouple the
.// client model objects from the tree viewer and the hierarchy it 
.// imposes.
.//
.function create_generic_adapters
  .param inst_ref tree_node
  .param string node_name
  .param string path
  .param string package
  .param string plugin_package
  .param string plugin_name
  .param string prefix
  .assign provider_name = "${prefix}ContentProvider"
  .//
  .assign adapter_name = "${node_name}Adapter"
  .assign attr_result = adapter_name
  .select any this_class from instances of O_OBJ where (selected.Key_Lett == tree_node.Key_Lett)
  .invoke result = get_class_name(this_class)
  .assign this_class_name = "${result.body}"
package ${package}.adapters;
//======================================================================
//
// File: ${path}/adapters/${adapter_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      $$Revision$$
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp.  All rights reserved.
//
//========================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not 
// use this file except in compliance with the License.  You may obtain a copy 
// of the License at
//
//       http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software 
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the 
// License for the specific language governing permissions and limitations under
// the License.
//======================================================================== 
//
// This class is responsible for decoupling the client model entity
// class ${this_class_name} from the tree viewer and the hierarchy
// it imposes.
//
import java.util.ArrayList;
import java.util.List;

.if (tree_node.Key_Lett == "S_SYS")
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.NullProgressMonitor;
import ${plugin_package}.${plugin_name};
.end if
import org.eclipse.jface.viewers.ITreeContentProvider;
import org.eclipse.jface.viewers.Viewer;
import org.xtuml.bp.core.*;
import org.xtuml.bp.core.common.*;
import ${package}.${provider_name};
  .select many child_specs related by tree_node->T_TPS[R1000]
  .for each spec in child_specs
    .select one child related by spec->T_TNS[R1001]
    .if ( child.Sorted )
      .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
      .invoke gcn = get_class_name(child_class)
      .assign child_class_name = "${gcn.body}"
import org.xtuml.bp.core.sorter.${child_class_name}Sorter;
    .end if
  .end for
/**
 * This file adapts the meta-model entity; '${this_class_name}'
 * so that it works with the Eclipse JFace user interface components.
 * <p>
 * Do not edit this class, it was created using the Project 
 * Technology MC-Java code generator product.
 * </p>
 */
public  class ${adapter_name} implements ITreeContentProvider {
  static ${adapter_name} $l{adapter_name} = null;
  /**
   * Returns the adapters singleton instance. If this
   * is the first time, the instance is created.
   */
  public static ${adapter_name} getInstance() {
    if ($l{adapter_name} == null) {
      $l{adapter_name} = new ${adapter_name}();
    }
    return $l{adapter_name};
  }
  /**
   * @see IContentProvider#inputChanged(Viewer, Object, Object)
   * Called when the tree's input has been changed
   */
  public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {
    // Nothing to do
  }
  /**
   * @see IContentProvider#dispose()
   * Called when this viewer is no longer needed
   */
  public void dispose() {
    // Nothing to dispose
  }
  /**
   * @see ITreeContentProvider#getParent(Object)
   * Returns the parent of this node
   */
  public Object getParent(Object arg) {
  .select many spec_set related by tree_node->T_TPS[R1001]
  .for each spec in spec_set
    .assign result_var = "result${info.unique_num}"
    .select one parent related by spec->T_TNS[R1000]
    .invoke rel_nav = generate_forward_rel_chain_nav(  spec.ParentChildRelChain, parent.Key_Lett, this_class_name, "arg", result_var ) 
${rel_nav.body}\
    if (${result_var} != null) {
      return ${result_var};
    }
    .end for
.if (tree_node.Key_Lett == "S_SYS")
	return Ooaofooa.getDefaultInstance();
.else
    return null;
.end if
  }
  /**
   * @see IStructuredContentProvider#getElements(Object)
   * Returns the elements below this node
   */
  public Object[] getElements(Object arg) {
  	return getChildren(arg);
  }

  /**
   * @see ITreeContentProvider#getChildren(Object)
   * Returns the children of this node
   */
  public Object[] getChildren(Object arg) {
    int resultSize = 0;
  .//
  .// We need to return a set of instances for each item that is specified
  .// as a child of the element represented by this adapter.
  .//
  .assign isSpecialCase = false
  .assign childCount = 0
  .for each spec in child_specs
    .select one child related by spec->T_TNS[R1001]
    .assign relNumber = "$tcf_rel{spec.ParentChildRelChain}"
    .assign query = spec.WhereClause
    .assign resultName = "$lr{child.CategoryName}_${relNumber}_${childCount}"
    .assign childCount = childCount + 1
    .invoke rel_nav = generate_backward_rel_chain_nav_with_query(tree_node.Key_Lett, spec.ParentChildRelChain, "many", "arg", resultName, true, query)
${rel_nav.body}\
    .if ( not child.Sorted )
      .assign alpha_sort = false
      .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
      .//
      .select one attr related by child_class->O_ATTR[R102] where ( selected.Name == "Name" )
      .if ( not_empty attr )
        .assign alpha_sort = true
      .else
        .select one op related by child_class->O_TFR[R115] where ( selected.Name == "get_name" )
        .if ( not_empty op )
          .assign alpha_sort = true
        .end if
      .end if
      .//
      .if ( alpha_sort )
    	        ${provider_name}.sort(${resultName});
      .end if
    .end if
    .if ((tree_node.Key_Lett == "SM_ISM") and (child.Key_Lett == "SM_EVT"))
        ${resultName} = removeNonLocalEvents(${resultName});
    .end if
    .if ((tree_node.Key_Lett == "I_EXE") and (child.Key_Lett != "C_PO"))
    if (((ComponentInstance_c)arg).getRealizedby() == null) {
      resultSize += ${resultName}.length;
    }
    .else
    resultSize += ${resultName}.length;
    .end if
  .end for
  .if ( not isSpecialCase )
    Object [] result = new Object [resultSize];
    .if (not_empty child_specs)
    int count = 0;
    .end if
  .end if
  .assign childCount = 0
  .for each spec in child_specs
    .select one child related by spec->T_TNS[R1001]
    .assign relNumber = "$tcf_rel{spec.ParentChildRelChain}"
    .assign resultName = "$lr{child.CategoryName}_${relNumber}_${childCount}"
    .assign childCount = childCount + 1
    .if ( child.Sorted )
      .select any child_class from instances of O_OBJ where (selected.Key_Lett == child.Key_Lett)
      .invoke gcn = get_class_name(child_class)
      .assign child_class_name = "${gcn.body}"
    ${child_class_name}Sorter sorter${child.Key_Lett} = new ${child_class_name}Sorter();
    sorter${child.Key_Lett}.sort(${resultName});
    .end if
    .if ((tree_node.Key_Lett == "I_EXE") and (child.Key_Lett != "C_PO"))
    if (((ComponentInstance_c)arg).getRealizedby() == null) {
    .end if
    for (int i = 0 ; i < ${resultName}.length ; i++) {
      result[count] = ${resultName}[i];
      count++;
    }
    .if ((tree_node.Key_Lett == "I_EXE") and (child.Key_Lett != "C_PO"))
    }
    .end if
  .end for
    return result;
  }
  /**
   * @see ITreeContentProvider#hasChildren(Object)
   * Returns true if this node has any children
   */
  public boolean hasChildren(Object arg) {
  .assign isSpecialCase = false
  .assign childCount = 0
  .for each spec in child_specs
    .select one child related by spec->T_TNS[R1001]
    .assign relNumber = "$tcf_rel{spec.ParentChildRelChain}"
    .assign resultName = "$lr{child.CategoryName}_${relNumber}_${childCount}"
    .assign childCount = childCount + 1
    .assign query = spec.WhereClause
    .invoke rel_nav = generate_backward_rel_chain_nav_with_query(tree_node.Key_Lett, spec.ParentChildRelChain, "many", "arg", resultName, true, query)
${rel_nav.body}\
    .if ((tree_node.Key_Lett == "SM_ISM") and (child.Key_Lett == "SM_EVT"))
        ${resultName} = removeNonLocalEvents(${resultName});
    .end if
    .if ((tree_node.Key_Lett == "I_EXE") and (child.Key_Lett != "C_PO"))
    if (((ComponentInstance_c)arg).getRealizedby() == null) {
    .end if
    if (${resultName}.length > 0) return true;
    .if ((tree_node.Key_Lett == "I_EXE") and (child.Key_Lett != "C_PO"))
    }
    .end if
  .end for
    return false;
  }
  .if (tree_node.Key_Lett == "SM_ISM")

	/**
	 * Returns an array of the events in the given array, minus those
	 * that are non-local.
	 */
	private StateMachineEvent_c[] removeNonLocalEvents(StateMachineEvent_c[] events)
	{
        // for each event in the given array
        List localEvents = new ArrayList();
        for (int i = 0; i < events.length; i++) {
            // if this event is local
            if (NonLocalEvent_c.getOneSM_NLEVTOnR526(SemEvent_c.getOneSM_SEVTOnR525(events[i])) == null) {
                // add it to our list of local events
                localEvents.add(events[i]);
            }
        }
        
        // return the set of local events
        events = new StateMachineEvent_c[localEvents.size()];
        localEvents.toArray(events);
        return events;
	}
  .end if	
}
.end function
