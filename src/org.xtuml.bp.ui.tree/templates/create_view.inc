.//=====================================================================
.//
.// File:      $RCSfile$
.// Version:   $Revision$
.// Modified:  $Date$
.//
.// (c) Copyright 2006-2014 by Mentor Graphics Corp. All rights reserved.
.//
.//=======================================================================
.// Licensed under the Apache License, Version 2.0 (the "License"); you may not
.// use this file except in compliance with the License.  You may obtain a copy
.// of the License at
.//
.//      http://www.apache.org/licenses/LICENSE-2.0
.//
.// Unless required by applicable law or agreed to in writing, software
.// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
.// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
.// License for the specific language governing permissions and limitations under
.// the License.
.//=======================================================================
.//
.// This file is responsible for creating the **VIEW_NAME** View
.// It is generated so that filters are defined for each tree
.// node, giving the user the ultimate flexibility over what
.// they want to see.
.//
.function create_**VIEW_FILENAME**
  .param string path
  .param string plugin_name
  .//
  .assign viewer_name = "**VIEW_NAME**"
  .assign attr_result = viewer_name  
package **VIEW_PACKAGE**;
//======================================================================
//
// File: ${path}/${viewer_name}.java
//
// WARNING:      Do not edit this generated file
// Generated by: ${info.arch_file_name}
// Version:      $$Revision$$
//
// (c) Copyright 2006-2014 by Mentor Graphics Corp. All rights reserved.
//
//=======================================================================
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License.  You may obtain a copy
// of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   See the
// License for the specific language governing permissions and limitations under
// the License.
//=======================================================================
//
// This class is the main entry point for the **VIEW_NAME** View.
// It is responsible for building the presentation to the user and
// for provideing the interface to the Eclipse infrastructure.
//
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Iterator;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceChangeEvent;
import org.eclipse.core.resources.IResourceChangeListener;
import org.eclipse.core.resources.IResourceDelta;
import org.eclipse.core.resources.IResourceDeltaVisitor;
import org.eclipse.core.resources.IWorkspace;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.IConfigurationElement;
import org.eclipse.core.runtime.IExtension;
import org.eclipse.core.runtime.IExtensionPoint;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Platform;
import org.eclipse.jface.action.Action;
import org.eclipse.jface.action.GroupMarker;
import org.eclipse.jface.action.IMenuListener;
import org.eclipse.jface.action.IMenuManager;
import org.eclipse.jface.action.IToolBarManager;
import org.eclipse.jface.action.MenuManager;
import org.eclipse.jface.action.Separator;
import org.eclipse.jface.viewers.DecoratingLabelProvider;
import org.eclipse.jface.viewers.ISelection;
import org.eclipse.jface.viewers.ILabelProvider;
import org.eclipse.jface.viewers.IOpenListener;
import org.eclipse.jface.viewers.ISelectionChangedListener;
import org.eclipse.jface.viewers.IStructuredSelection;
import org.eclipse.jface.viewers.OpenEvent;
import org.eclipse.jface.viewers.SelectionChangedEvent;
import org.eclipse.jface.viewers.TreeViewer;
import org.eclipse.jface.viewers.Viewer;
import org.eclipse.jface.viewers.ViewerFilter;
import org.eclipse.swt.SWT;
import org.eclipse.swt.layout.FillLayout;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Control;
import org.eclipse.swt.widgets.Menu;
import org.eclipse.ui.IActionBars;
import org.eclipse.ui.IEditorInput;
import org.eclipse.ui.IEditorPart;
import org.eclipse.ui.ISelectionListener;
import org.eclipse.ui.IWorkbenchPart;
import org.eclipse.ui.IWorkbenchActionConstants;
import org.eclipse.ui.PartInitException;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.actions.ActionFactory;
import org.eclipse.ui.actions.ExportResourcesAction;
import org.eclipse.ui.actions.ImportResourcesAction;
import org.eclipse.ui.actions.NewWizardMenu;
import org.eclipse.ui.actions.RefreshAction;
import org.eclipse.ui.part.ViewPart;
import org.eclipse.ui.views.framelist.BackAction;
import org.eclipse.ui.views.framelist.ForwardAction;
import org.eclipse.ui.views.framelist.FrameList;
import org.eclipse.ui.views.framelist.TreeViewerFrameSource;
import org.eclipse.ui.views.framelist.UpAction;
import org.eclipse.ui.views.properties.IPropertySheetPage;
import org.eclipse.ui.views.properties.PropertySheetPage;
import org.osgi.framework.Bundle;

import org.xtuml.bp.core.*;
import org.xtuml.bp.core.common.*;
import org.xtuml.bp.core.ui.DeleteAction;
import org.xtuml.bp.core.ui.RenameAction;
import org.xtuml.bp.core.ui.Selection;
import org.xtuml.bp.core.util.UIUtil;

import org.xtuml.bp.ui.properties.ModelPropertySourceProvider;
import **PROJECT**.*;
import **ACTIONS_PACKAGE**.*;

/**
 * **VIEW_NAME** allows the user to navigate the BridgePoint
 * metamodel. It provides a tree view analogous to that provided
 * by the Java Package Explorer.
 * 
 * @see ViewPart
 */
public class ${viewer_name} extends ViewPart {
  private static final String COLLAPSE = "Collapse All";
  private static final String OPEN = "open";
  private static final String HIDE_STATICS = "Hide Static Members";
  .select many tree_nodes from instances of T_TNS
  .for each node in tree_nodes 
  private static final String HIDE_$U_{node.CategoryName} = "Hide ${node.CategoryName}";
  .end for
  private FrameList frames;
  protected **TREEVIEWER_PREFIX**TreeViewer treeViewer;
  protected **LABEL_PROVIDER_PREFIX**LabelProvider labelProvider;
  protected MenuManager menuManager;
  protected Action collapseAll, linkWithEditor;
  protected Action back, fwd, up;
  protected Action cut, copy, paste;
  protected Action open, delete, rename; 
  protected Action fileImport, fileExport;
  protected Action treeRefresh;
  protected Action hideStatics;
  protected Action\
  .for each node in tree_nodes 
 hide$r{node.CategoryName}\
    .if (not_last tree_nodes)
,\
    .else
;
    .end if
  .end for
  protected FilterSelectionAction filters;
  protected ViewerFilter filterStatics;
  protected ViewerFilter\
  .for each node in tree_nodes 
 filter$r{node.CategoryName}\
    .if (not_last tree_nodes)
,\
    .else
;
    .end if
  .end for

  private IModelChangeListener m_modelChangeListener;
  private ISelectionChangedListener m_selChangedListener;
  private ISelectionListener m_selListener;

    private static Selection selection = Selection.getInstance();
    
  /**
   * The constructor.
   */
  public ${viewer_name}() {
  }
  /**
   * Returns the tree viewer for the **VIEW_NAME** window
   */
  public **TREEVIEWER_PREFIX**TreeViewer getTreeViewer() {
    return treeViewer;
  }
  /*
   * @see IWorkbenchPart#createPartControl(Composite)
   */
  public void createPartControl(Composite parent) {
    // Create the view's layout
    FillLayout layout = new FillLayout();
    parent.setLayout(layout);
    treeViewer = new **TREEVIEWER_PREFIX**TreeViewer(parent);
    treeViewer.setContentProvider(new **PREFIX**ContentProvider());
    labelProvider = new **LABEL_PROVIDER_PREFIX**LabelProvider();
    treeViewer.setLabelProvider(labelProvider);
    treeViewer.setUseHashlookup(true);
    // Create menu, toolbar and filters.
    createActions();
    createMenus();
    createToolbar();
    createFilters();
    hookListeners();
    initLabelProvider(treeViewer);
	treeViewer.setInput(Ooaofooa.getDefaultInstance());
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.DELETE.getId(),
      delete);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.RENAME.getId(),
      rename);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.COPY.getId(),
      copy);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.CUT.getId(),
      cut);
    getViewSite().getActionBars().setGlobalActionHandler(
      ActionFactory.PASTE.getId(),
      paste);
    // Set help for the view 
    PlatformUI.getWorkbench().getHelpSystem().setHelp(treeViewer.getControl(), I**HELPCONTEXTIDS_PREFIX**HelpContextIds.**VIEW_NAME**Id);
  }
  /**
   * Hook up all the listeners needed by **VIEW_NAME**
   */    
  protected void hookListeners() {
		m_selListener = new ISelectionListener() {
			public void selectionChanged(
					IWorkbenchPart part,
					ISelection selection) {
					if (part instanceof **VIEW_NAME**) {
						if (selection instanceof IStructuredSelection) {
						  if(!getTreeViewer().getTree().isDisposed()) {
							  IStructuredSelection sel = (IStructuredSelection) selection;
							  setTreeSelection(getTreeViewer(), sel);
							}
						}
					}
				}
			};
		getSite().getPage().addSelectionListener(m_selListener);  
    treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
        // Transfer the selection to the model
        selection.setSelection(event.getSelection());
      }
    });
    m_selChangedListener = new ISelectionChangedListener() {
      public void selectionChanged(SelectionChangedEvent event) {
	  	keyActionsActivation();
        if (!getTreeViewer().getTree().isDisposed()) {
          if (linkWithEditor.isChecked()){
            // transfer the selection to the tree, but avoid having the tree 
            // viewer report its selection change to its listeners, as if what the 
            // model is reporting as selected is not contained in the tree
            // (such as when a connector is selected), we don't want the
            // tree's newly empty selection being propagated back to the model 
            // by the treeview-listener, above; see issue 453 for more context
            IStructuredSelection selection = (IStructuredSelection)event.getSelection();
            setTreeSelection(getTreeViewer(), selection);
          }
        }
      }
    };
    selection.addSelectionChangedListener(m_selChangedListener);
    m_modelChangeListener = new ModelChangeAdapter() {
		public void modelElementLoaded(ModelChangedEvent event) {
			//Overriden to do nothing since performDefault() is overriden.
		}
		public void modelElementUnloaded(ModelChangedEvent event) {
			if (!getTreeViewer().getTree().isDisposed()) {
				Object modelElement = event.getModelElement();
	
				**TREEVIEWER_PREFIX**TreeViewer viewer = getTreeViewer();
				Object parent = ((**PREFIX**ContentProvider) viewer.getContentProvider()).getParent(modelElement);
				if (parent != null) {
					if (parent instanceof Domain_c) {
						viewer.replaceProxyWithDomain((Domain_c) parent);
					}
				}
				UIUtil.refreshViewer(viewer, parent);
			}
		}
		
		protected void performDefault(ModelChangedEvent event, IModelDelta delta){
  			Object modelElement = null;
  			if(delta == null){
  				modelElement = event.getModelElement();
  			}else{
  				modelElement = delta.getModelElement();
  			}
			internalPerformDefault(modelElement);
		}
	
		private void internalPerformDefault(Object modelElement) {
			if (!getTreeViewer().getTree().isDisposed()) {					
	
			Object parent = null;
			// Need to refresh the parent if possible
            **TREEVIEWER_PREFIX**TreeViewer viewer = getTreeViewer();
			if (classInTree(modelElement)) {
				parent = ((**PREFIX**ContentProvider) viewer.getContentProvider()).getParent(modelElement);
			}
			if (parent != null) {
				if (parent instanceof Domain_c) {
	                        viewer.replaceProxyWithDomain((Domain_c) parent);
				}
	                    UIUtil.refreshViewer(viewer, parent);
			} else {
					if (modelElement instanceof NonRootModelElement) {
						Ooaofooa mr = (Ooaofooa) (((NonRootModelElement) modelElement).getModelRoot());
						parent = mr.getRoot();
						if (parent != null) {
	                                UIUtil.refreshViewer(viewer, parent);
						}
					}
				}
			}
		}
    };
    Ooaofooa.addModelChangeListenerToAll(m_modelChangeListener);
    treeViewer.addOpenListener(new IOpenListener() {
      public void open(OpenEvent event) {
        handleOpen();
      }
    });
  }
  private static void setTreeSelection(**TREEVIEWER_PREFIX**TreeViewer tv, IStructuredSelection sel) {
    tv.setSelectionToWidget(sel, true);

    // scroll to reveal all elements of the new selection
    for (Iterator iterator = sel.iterator(); iterator.hasNext();) {
      Object element = iterator.next();
      tv.reveal(element);
    }
  }
  public static final boolean classInTree( Object o )
  {
  .// declare two empty inst_ref_set<O_OBJ>'s
  .select many all_referenced_class_set from instances of O_OBJ where (selected.Name == "-1" )
  .assign empty_class_set = all_referenced_class_set
  .//
  .for each node in tree_nodes 
    .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .assign all_referenced_class_set = all_referenced_class_set | class
  .end for
  .//
  .// add any classes that are only called out in T_TNS.NamingAttributeRelChain
  .//
  .for each node in tree_nodes
    .invoke arcc = add_rel_chain_classes( empty_class_set, node.NamingAttributeRelChain )
    .assign all_referenced_class_set = all_referenced_class_set | arcc.class_set
  .end for
  .//
  .// now do the same thing for T_TPS.ParentChildRelChain
  .//
  .select many parent_nodes from instances of T_TPS
  .for each parent in parent_nodes 
    .invoke arcc = add_rel_chain_classes( empty_class_set, parent.ParentChildRelChain )
    .assign all_referenced_class_set = all_referenced_class_set | arcc.class_set
  .end for
  .//
  .// special case classes
  .select any class from instances of O_OBJ where (selected.Key_Lett == "O_RATTR")
  .assign all_referenced_class_set = all_referenced_class_set | class
  .select any class from instances of O_OBJ where (selected.Key_Lett == "O_REF")
  .assign all_referenced_class_set = all_referenced_class_set | class
  .//
  .for each class in all_referenced_class_set 
    .invoke cn = get_class_name( class )
    if ( o instanceof ${cn.body} ) return true;
  .end for
    return false;
  }
  /**
   * Create the Actions provided by **VIEW_NAME**
   */
  protected void createActions() {
    frames = new FrameList(new TreeViewerFrameSource(getTreeViewer()));
    back = new BackAction(frames) {
      public void run() {
      }
    };
    fwd = new ForwardAction(frames) {
      public void run() {
      }
    };
    up = new UpAction(frames) {
      public void run() {
      }
    };
    collapseAll = new Action(COLLAPSE) {
      public void run() {
        getTreeViewer().collapseAll();
      }
    };
    collapseAll.setToolTipText(COLLAPSE);
    collapseAll.setImageDescriptor(CorePlugin.getImageDescriptor("collapseall.gif")); //$$NON-NLS-1$$
    PlatformUI.getWorkbench().getHelpSystem().setHelp(collapseAll, I**HELPCONTEXTIDS_PREFIX**HelpContextIds.COLLAPSE_ALL_ACTION);
    linkWithEditor = new Action(IWorkbenchActionConstants.SHOW_IN) {
      public void run() {
        IStructuredSelection selection = (IStructuredSelection)Selection.getInstance().getSelection();
        getTreeViewer().setSelection(selection);
        for (Iterator iterator = selection.iterator(); iterator.hasNext();) {
          Object element = iterator.next();
          getTreeViewer().reveal(element);
        }
      }
    };
    linkWithEditor.setChecked(false);
    linkWithEditor.setText("Link With Editor");
    linkWithEditor.setToolTipText("Link with Editor");
    linkWithEditor.setImageDescriptor(CorePlugin.getImageDescriptor("synced.gif")); //$$NON-NLS-1$$
    // 'New' is provided as a sub-menu only. See 'createMenus'
    open = new Action(OPEN){
      public void run(){
        handleOpen();
      }
    };
    open.setText("Open");
    open.setToolTipText("Open this model Element");
    // 'Open With' is provided as a sub-menu only. See 'createMenus'
	cut = new Action(ActionFactory.CUT.getId()) {
      public void run() {
      }
	};
    cut.setText("Cut");
    cut.setToolTipText("Cut this model Element to the clipboard");
    cut.setImageDescriptor(CorePlugin.getImageDescriptor("cut_edit.gif")); //$$NON-NLS-1$$
    cut.setEnabled(false); // Retargetable Actions work removes this line
    copy = new Action(ActionFactory.COPY.getId()) {
      public void run() {
      }
    };
    copy.setText("Copy");
    copy.setToolTipText("Copy this model Element to the clipboard");
    copy.setImageDescriptor(CorePlugin.getImageDescriptor("copy_edit.gif")); //$$NON-NLS-1$$
    copy.setEnabled(false); // Retargetable Actions work removes this line
    paste = new Action(ActionFactory.PASTE.getId()) {
      public void run() {
      }
    };
    paste.setText("Paste");
    paste.setToolTipText("Paste from the clipboard");
    paste.setImageDescriptor(CorePlugin
        ..getImageDescriptor("paste_edit.gif")); //$$NON-NLS-1$$
    paste.setEnabled(false); // Retargetable Actions work removes this line
    //
    // Delete and Rename are retargetable actions defined by core.
    //
    delete = CorePlugin.getDeleteAction();
    rename = CorePlugin.getRenameAction(treeViewer);
    //
    fileImport = new Action(ActionFactory.IMPORT.getId()){
      public void run(){
		ImportResourcesAction ira = new ImportResourcesAction(
		    CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow());
		ira.run();
      }
    };
    fileImport.setText("Import...");
    fileImport.setToolTipText("Import a BridgePoint file");
    fileImport.setImageDescriptor(CorePlugin.getImageDescriptor("import_wiz.gif")); //$$NON-NLS-1$$
    fileExport = new Action(ActionFactory.EXPORT.getId()){
      public void run(){
		ExportResourcesAction era = new ExportResourcesAction(
		    CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow());
		era.run();
      }
    };
    fileExport.setText("Export...");
    fileExport.setToolTipText("Export a BridgePoint file");
    fileExport.setImageDescriptor(CorePlugin.getImageDescriptor("export_wiz.gif")); //$$NON-NLS-1$$
    hideStatics = new Action(HIDE_STATICS) {
      public void run() {
        updateFilter(hideStatics);
      }
    };
	treeRefresh = new Action(ActionFactory.REFRESH.getId()) {
		public void run() {
			RefreshAction ra = new RefreshAction(
				CorePlugin.getDefault().getWorkbench().getActiveWorkbenchWindow().getShell());
			ra.run();
			getTreeViewer().refresh();
		}
	};
	treeRefresh.setText("Refresh");
	treeRefresh.setToolTipText("Refresh the tree");
	treeRefresh.setImageDescriptor(
		CorePlugin.getImageDescriptor("refresh.gif")); //$$NON-NLS-1$$
	treeRefresh.setAccelerator(SWT.F5);
	treeRefresh.setActionDefinitionId("org.eclipse.ui.file.refresh"); //$$NON-NLS-1$$
	getSite().getKeyBindingService().registerAction(treeRefresh);

    hideStatics.setChecked(false);
    hideStatics.setToolTipText(HIDE_STATICS);
  .for each node in tree_nodes
    hide$r{node.CategoryName} = new Action(HIDE_$U_{node.CategoryName}) {
      public void run() {
        updateFilter(hide$r{node.CategoryName});
      }
    };
    hide$r{node.CategoryName}.setChecked(false);
    hide$r{node.CategoryName}.setToolTipText(HIDE_$U_{node.CategoryName});
  .end for
    filters = new FilterSelectionAction(this, "Filters...");
    filters.setImageDescriptor(CorePlugin.getImageDescriptor("filter_ps.gif")); //$$NON-NLS-1$$
  }
  /**
   * Create the menus for the **VIEW_NAME**
   */  
  protected void createMenus() {
    // Context Menu
    MenuManager menuManager = new MenuManager("#PopupMenu"); //$$NON-NLS-1$$
    menuManager.setRemoveAllWhenShown(true);
    final MenuManager createMenuManager = new MenuManager("Ne&w", "org.xtuml.bp.ui.newroot"); //$$NON-NLS-2$$
    final MenuManager openMenuManager = new MenuManager("Open Wit&h", "org.xtuml.bp.ui.openroot"); //$$NON-NLS-2$$
    menuManager.addMenuListener(new IMenuListener() {
      public void menuAboutToShow(IMenuManager mgr) {
        mgr.add(createMenuManager);
        createMenuManager.removeAll();
        createMenuManager.add(new GroupMarker("org.xtuml.bp.ui.newmenu")); //$$NON-NLS-1$$
        createMenuManager.add(new NewWizardMenu(getSite().getWorkbenchWindow()));
        mgr.add(open);
        mgr.add(openMenuManager);
        openMenuManager.removeAll();
        openMenuManager.add(new GroupMarker("org.xtuml.bp.ui.openmenu")); //$$NON-NLS-1$$
        mgr.add(new Separator("org.xtuml.bp.ui.context-internal")); //$$NON-NLS-1$$
        mgr.add(new Separator("org.xtuml.bp.ui.context-internal-end")); //$$NON-NLS-1$$
        mgr.add(cut);
        mgr.add(copy);
        mgr.add(paste);
        mgr.add(delete);
        mgr.add(rename);
        mgr.add(new Separator());
        mgr.add(fileImport);
        mgr.add(fileExport);
		mgr.add(new Separator());
		mgr.add(treeRefresh);
        // If this is omitted, the platform complains because
        // it can't allow third party plug-ins to extend the menu
        // This is important for those who wish to use change
        // management plugins because Team menu items are added here.
        mgr.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
      }
    });
    Menu menu = menuManager.createContextMenu(treeViewer.getTree());
    treeViewer.getTree().setMenu(menu);
    getSite().setSelectionProvider(selection);
    getSite().registerContextMenu(menuManager, selection);
    // Titlebar Menu
    IMenuManager rootMenuManager = getViewSite().getActionBars().getMenuManager();
    rootMenuManager.setRemoveAllWhenShown(true);
    rootMenuManager.addMenuListener(new IMenuListener() {
      public void menuAboutToShow(IMenuManager mgr) {
        fillMenu(mgr);
      }
    });
    fillMenu(rootMenuManager);
  }
  /**
   * Fill the **VIEW_NAME**'s Titlebar dropdown menu 
   */  
  protected void fillMenu(IMenuManager rootMenuManager) {
    // These actions are being presented in the menu and so should have an icon
    hideStatics.setImageDescriptor(CorePlugin.getImageDescriptor("static_co.gif")); //$$NON-NLS-1$$
    rootMenuManager.add(hideStatics);
    hideOperations.setImageDescriptor(CorePlugin.getImageDescriptor("methpub_obj_co.gif")); //$$NON-NLS-1$$
    rootMenuManager.add(hideOperations);
    rootMenuManager.add(filters);
    rootMenuManager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
    rootMenuManager.add(linkWithEditor);
  }
  /**
   * Create the view filters for the **VIEW_NAME** window
   */
  .select any op_class from instances of O_OBJ where (selected.Key_Lett == "O_TFR")
  .invoke op = get_class_name(op_class)
  .select any fn_class from instances of O_OBJ where (selected.Key_Lett == "S_SYNC")
  .invoke fn = get_class_name(fn_class)
  protected void createFilters() {
    filterStatics = new ViewerFilter() {
      public boolean select(Viewer viewer, Object parentElement, Object element) {
        if (element instanceof ${op.body}) {
          return (((${op.body})element).getInstance_based() == Scope_c.Instance);
        }
        if (element instanceof ${fn.body}) {
          return false;
        }
        return true;
      }
    };
  .for each node in tree_nodes
    .select any class from instances of O_OBJ where (selected.Key_Lett == node.Key_Lett)
    .invoke cn = get_class_name( class )
    filter$r{node.CategoryName} = new ViewerFilter() {
      public boolean select(Viewer viewer, Object parentElement, Object element) {
    .if ( class.AdapterName == "IFile" )
        return !(element instanceof ${cn.body})
            && !(element instanceof $cr{class.Name}Proxy);
    .else
        return !(element instanceof ${cn.body});
    .end if
      }
    };
    .end for
    **PREFIX**FiltersContentProvider contentProvider = new **PREFIX**FiltersContentProvider();
    String [] selections = contentProvider.getInitialSelections();
    updateFilters(selections); 
  }
  /**
   * Update the **VIEW_NAME**'s view filters 
   */
  public void updateFilters(String[] filters){
  .for each node in tree_nodes
    hide$r{node.CategoryName}.setChecked(false);
    updateFilter(hide$r{node.CategoryName});
  .end for
    for (int i=0; i <  filters.length; i++){
  .for each node in tree_nodes
      if (filters[i].equals("${node.CategoryName}")) {
        hide$r{node.CategoryName}.setChecked(true);
        updateFilter(hide$r{node.CategoryName});
      }
  .end for
    }
  }
  /**
   * Update a single filter
   */
  /* Multiple filters can be enabled at a time. */
  protected void updateFilter(Action action) {
    if(action == hideStatics) {
      if(action.isChecked()) {
        treeViewer.addFilter(filterStatics);
      } else {
        treeViewer.removeFilter(filterStatics);
      }
      return;
    }
    .for each node in tree_nodes
    if(action == hide$r{node.CategoryName}) {
      if(action.isChecked()) {
        treeViewer.addFilter(filter$r{node.CategoryName});
      } else {
        treeViewer.removeFilter(filter$r{node.CategoryName});
      }
      return;
    }
    .end for
  }
  /**
   * Create the tool bar for the **VIEW_NAME** 
   */  
  protected void createToolbar() {
    IActionBars actionBars = getViewSite().getActionBars();
    actionBars.setGlobalActionHandler(ActionFactory.BACK.getId(), back);
    actionBars.setGlobalActionHandler(
       ActionFactory.FORWARD.getId(),
       fwd);
    actionBars.setGlobalActionHandler(ActionFactory.UP.getId(), up);
    IToolBarManager toolBarManager = actionBars.getToolBarManager();
    toolBarManager.add(back);
    toolBarManager.add(fwd);
    toolBarManager.add(up);
    toolBarManager.add(new Separator());
    toolBarManager.add(collapseAll);
    toolBarManager.add(linkWithEditor);
  }
  /*
   * @see IWorkbenchPart#setFocus()
   */
  public void setFocus() {
    Viewer viewer = getTreeViewer();
    if (viewer != null) {
      Control c = viewer.getControl();
      if (!c.isFocusControl()) {
        c.setFocus();
      }
    }
  }
  /**
   * Returns an adapter if available
   * @see IAdaptable#getAdapter
   */
  public Object getAdapter(Class adapter) {
    if (adapter.equals(IPropertySheetPage.class)) {
      return getPropertySheet();
    }
    return super.getAdapter(adapter);
  }
  /**
   * return a property sheet if available
   */
  protected IPropertySheetPage getPropertySheet() {
        PropertySheetPage pss =  new PropertySheetPage();
        pss.setPropertySourceProvider(new ModelPropertySourceProvider());
        return pss;
  }
  /**
   * Fire up an editor
   */
  private IEditorPart handleOpen() {
    
    IStructuredSelection sel = (IStructuredSelection) selection.getSelection();
	if (sel.isEmpty())
	{
		return null;
	}
	Object current = sel.iterator().next();    
	if (current instanceof DomainProxy) {
		current = ((DomainProxy) current).getActualElement(true);
		if (current == null) {
            //
            // Error message was already displayed
            //
			return null;
		}
	}
    String name = current.getClass().getName();
    //
    // Get the registry
    //
    IExtensionRegistry reg = Platform.getExtensionRegistry();
    //
    // Get all the plugins that have extended this point
    //
    IExtensionPoint extPt = reg.getExtensionPoint("org.xtuml.bp.core.editors"); //$$NON-NLS-1$$
    IExtension[] exts = extPt.getExtensions();
    // Repeat for each extension until we find a default editor
    for (int i=0; i < exts.length; i++) {
      IConfigurationElement[] elems = exts[i].getConfigurationElements();
      for (int j=0; j < elems.length; j++) {
        // Find the editor elements
        if (elems[j].getName().equals("editor")){                                  //$$NON-NLS-1$$
          IConfigurationElement[] edElems = elems[j].getChildren();
          for (int k=0; k < edElems.length; k++) {
            //
            // Is this editor the default for the current model element ?
            //
            if (edElems[k].getName().equals("defaultFor") &&                       //$$NON-NLS-1$$
                edElems[k].getAttribute("class").equals(name) ) {                  //$$NON-NLS-1$$
              try {
                //
                // Get the class supplied for the input
                //
                Bundle bundle = Platform.getBundle(elems[j]
                                      ..getDeclaringExtension().getNamespace());
                Class inputClass = bundle.loadClass(
                                       elems[j].getAttribute("input"));//$$NON-NLS-1$$
                Class[] type = new Class[1];
                type[0] = Object.class;
                //
                // Dynamically get the method createInstance, the supplied class must implement this
                //
                Method createInstanceMethod = inputClass.getMethod("createInstance", type);          //$$NON-NLS-1$$
                Object[] args = new Object[1];
                args[0] = current;
                //
                // Invoke the method.
                // The method is static; no instance is needed, so first argument is null
                //
                IEditorInput input = (IEditorInput)createInstanceMethod.invoke(null, args);
                //
                // pass the input to the Eclipse editor, along with the class name supplied by
                // the extending plugin.
                //
                if (input != null) {
                  return PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().openEditor(
                    input,
                    elems[j].getAttribute("class"));                                 //$$NON-NLS-1$$
                }
                return null;
              }
              catch (ClassNotFoundException e){
                CorePlugin.logError("Input Class not found", e);//$$NON-NLS-1$$
              }
              catch (NoSuchMethodException e) {
                CorePlugin.logError("Class does not implement static method createInstance", e);//$$NON-NLS-1$$
              }
              catch (InvocationTargetException e) {
                CorePlugin.logError("Exception occured on invocation of static method createInstance of the Target", (Exception)e.getTargetException());//$$NON-NLS-1$$
              }
              catch (IllegalAccessException e) {
                CorePlugin.logError("Target does not support static method createInstance", e);//$$NON-NLS-1$$
              }
              catch (PartInitException e) {
                CorePlugin.logError("Could not activate Editor", e);//$$NON-NLS-1$$
              }
            }
          }
        }
      }
    }

    return null; 
  }
  /**
   * Dispose of the **VIEW_NAME** widget
   */ 
  public void dispose() {
    super.dispose();
    Ooaofooa.removeModelChangeListenerFromAll(m_modelChangeListener);
    selection.removeSelectionChangedListener(m_selChangedListener);
	getSite().getPage().removeSelectionListener(m_selListener);    
  }
  /**
   * Initialize the Label provider to link it into the chain 
   * of platform label decorators.
   */
  protected void initLabelProvider(TreeViewer viewer){
    viewer.setLabelProvider(
       new DecoratingLabelProvider(
                              (ILabelProvider)viewer.getLabelProvider(),
                              CorePlugin.getDefault().getWorkbench().
                              getDecoratorManager().getLabelDecorator()));
  }

	/**
	 * Sets whether this **VIEW_NAME**'s selection is linked to that of the 
	 * whichever editor is currently open.  This method is used by
	 * automated test programs to simulate pressing/unpressing the 
	 * "Link with Editor" button of the **VIEW_NAME**.
	 */ 
	public void setLinkWithEditor(boolean link)
	{
		linkWithEditor.setChecked(link);
	}
    /**
     * Have this explorer-view behave as if its open-action was just
     * invoked. Returns the editor that was opened. For automated test purposes.
     */
    public IEditorPart doOpen() {
        return handleOpen();
    }

    /**
     * Have this explorer-view behave as if its delete-action was just
     * invoked.  For automated test purposes.
     */
    public void doDelete() {
        delete.run();
    }
	/**
     * To disable or Enable rename and delete actions
     * 
     */
	private void keyActionsActivation() {
		IStructuredSelection structuredSelection = Selection.getInstance().getStructuredSelection();
		Object context = structuredSelection.getFirstElement();
		if (context instanceof NonRootModelElement) {
			rename.setEnabled(RenameAction.canRenameAction());
		}
		boolean enableDel = false;
		IStructuredSelection selection = Selection.getInstance().getStructuredSelection();
		if (!selection.isEmpty()) {
			enableDel = true;
			// Iterate through removing elements that are only graphical
			for (Iterator iter = selection.iterator(); iter.hasNext();) {
				Object current = iter.next();
				if (!(current instanceof NonRootModelElement)) {
					enableDel = false;
					break;
				}
			}

		}
		if (enableDel) {
			delete.setEnabled(DeleteAction.canDeleteAction());
		} else {
			delete.setEnabled(enableDel);
		}
	}
}
.end function
.//
.function add_rel_chain_classes
  .param inst_ref_set p_result_set   .// an empty inst_ref_set<O_OBJ>
  .param string p_rel_chain
  .//
  .while ("$r{p_rel_chain}" != "")
    .invoke nav = parse_chain(p_rel_chain, "backward")
    .if (not_empty nav.class)
      .assign cl = nav.class
      .assign p_result_set = p_result_set | cl
    .end if
    .assign p_rel_chain = nav.remainder
  .end while
  .assign attr_class_set = p_result_set
.end function

